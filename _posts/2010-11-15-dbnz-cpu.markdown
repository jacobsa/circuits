---
layout: post
title: DBNZ CPU
---

I've decided to build a CPU that supports only one instruction: `DBNZ`. That
is, Decrement and Branch if Not Zero. Each instruction consists of two bytes.
The first gives a memory location whose value should be decremented, and the
second consists of the memory location from which to fetch the next instruction
if the result is non-zero. Using only this instruction and some self-modifying
code cleverness, you can write a surprising number of programs.

Following the examples I saw in [Computer Organization and Design] [coad], I've
sketched out a data path for the CPU:

![DBNZ CPU data path](/circuits/images/dbnz_cpu_data_path.png)

Some relevant pieces (all registers, adders, and buses are 8 bits wide):

 *  `PC` is a register that contains the address of the instruction to
    be fetched. It can be set from the +1 adder (for incrementing), or from
    `Ins B` (for branches). The +1 adder is set up to raise a `Halt` signal
    that will halt the external clock circuitry when the CPU jumps to `0xFF`.

 *  There is an SRAM unit that can be told to store the supplied write data at
    the given address, or to read the data at the given address. The address is
    supplied by `PC` (for loading instructions) or `Ins A` (for loading values
    to be decremented).

 *  `Ins A` holds the first byte of the instruction, i.e. the address of the
    value to be decremented.

 *  `Ins B` holds the second byte of the instruction, i.e. the address to jump
    to if the result of the decrement is not zero.

 *  `Val` holds the value to be decremented, and is set up to send its value
    from an adder that will do the decrementing. The adder is set up to raise
    a `ZeroRes` signal when the result of decrementing is zero; this feeds into
    the control circuitry.

Here's the control logic:

![DBNZ CPU control flow](/circuits/images/dbnz_cpu_control_flow.png)

 1. Set up the memory to read from the address in `PC`, and prepare `PC` to be
    incremented. (The value from the adder will be stored on the rising edge of
    `PCWrite`, asserted in the next state.)

 2. Store the first byte of the instruction into `Ins A` and increment `PC`.
    (Assuming no large clock skew, there's no race condition here because the
    hold time required for storing into `Ins A` is much lower than the
    propogation delay of `PC`, much less that of the SRAM.) Keep `MemRead`
    asserted with `AddrSel=1` so that the memory outputs the next byte.

 3. Store the second byte of the instruction into `Ins B` and increment `PC`
    again. Set up the memory to read from the address in the first byte of the
    instruction.

 4. Store the value pointed at by `Ins A` into `Val`. The adder will then
    output that value minus one. Continue to set `AddrSel=0` so that this can
    be written back to the memory.

 5. Write the decremented value back to memory. Set up `PC` to read from `Ins
    B` in case we jump. If the decrementing logic says that the result is zero,
    fall through to the next instruction in memory by going to state 1.

 6. Store the jump target into `PC`.

[coad]: http://www.amazon.com/Computer-Organization-Design-Third-Architecture/dp/1558606041/ref=tmm_pap_title_1
